{"version":3,"file":"init.mjs","sources":["../../../../../../packages/localize/init/index.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {ɵ$localize as $localize, ɵ_global as _global, ɵLocalizeFn as LocalizeFn, ɵTranslateFn as TranslateFn} from '@angular/localize';\n\nexport {$localize, LocalizeFn, TranslateFn};\n\n// Attach $localize to the global context, as a side-effect of this module.\n_global.$localize = $localize;\n\n// `declare global` allows us to escape the current module and place types on the global namespace\ndeclare global {\n  /**\n   * Tag a template literal string for localization.\n   *\n   * For example:\n   *\n   * ```ts\n   * $localize `some string to localize`\n   * ```\n   *\n   * **Providing meaning, description and id**\n   *\n   * You can optionally specify one or more of `meaning`, `description` and `id` for a localized\n   * string by pre-pending it with a colon delimited block of the form:\n   *\n   * ```ts\n   * $localize`:meaning|description@@id:source message text`;\n   *\n   * $localize`:meaning|:source message text`;\n   * $localize`:description:source message text`;\n   * $localize`:@@id:source message text`;\n   * ```\n   *\n   * This format is the same as that used for `i18n` markers in Angular templates. See the\n   * [Angular i18n guide](guide/i18n-common-prepare#mark-text-in-component-template).\n   *\n   * **Naming placeholders**\n   *\n   * If the template literal string contains expressions, then the expressions will be automatically\n   * associated with placeholder names for you.\n   *\n   * For example:\n   *\n   * ```ts\n   * $localize `Hi ${name}! There are ${items.length} items.`;\n   * ```\n   *\n   * will generate a message-source of `Hi {$PH}! There are {$PH_1} items`.\n   *\n   * The recommended practice is to name the placeholder associated with each expression though.\n   *\n   * Do this by providing the placeholder name wrapped in `:` characters directly after the\n   * expression. These placeholder names are stripped out of the rendered localized string.\n   *\n   * For example, to name the `items.length` expression placeholder `itemCount` you write:\n   *\n   * ```ts\n   * $localize `There are ${items.length}:itemCount: items`;\n   * ```\n   *\n   * **Escaping colon markers**\n   *\n   * If you need to use a `:` character directly at the start of a tagged string that has no\n   * metadata block, or directly after a substitution expression that has no name you must escape\n   * the `:` by preceding it with a backslash:\n   *\n   * For example:\n   *\n   * ```ts\n   * // message has a metadata block so no need to escape colon\n   * $localize `:some description::this message starts with a colon (:)`;\n   * // no metadata block so the colon must be escaped\n   * $localize `\\:this message starts with a colon (:)`;\n   * ```\n   *\n   * ```ts\n   * // named substitution so no need to escape colon\n   * $localize `${label}:label:: ${}`\n   * // anonymous substitution so colon must be escaped\n   * $localize `${label}\\: ${}`\n   * ```\n   *\n   * **Processing localized strings:**\n   *\n   * There are three scenarios:\n   *\n   * * **compile-time inlining**: the `$localize` tag is transformed at compile time by a\n   * transpiler, removing the tag and replacing the template literal string with a translated\n   * literal string from a collection of translations provided to the transpilation tool.\n   *\n   * * **run-time evaluation**: the `$localize` tag is a run-time function that replaces and\n   * reorders the parts (static strings and expressions) of the template literal string with strings\n   * from a collection of translations loaded at run-time.\n   *\n   * * **pass-through evaluation**: the `$localize` tag is a run-time function that simply evaluates\n   * the original template literal string without applying any translations to the parts. This\n   * version is used during development or where there is no need to translate the localized\n   * template literals.\n   *\n   * @param messageParts a collection of the static parts of the template string.\n   * @param expressions a collection of the values of each placeholder in the template string.\n   * @returns the translated string, with the `messageParts` and `expressions` interleaved together.\n   */\n  const $localize: LocalizeFn;\n}\n"],"names":["_global","$localize"],"mappings":";;;;;;;;;AAAA;;;;;;AAMG;AAKH;AACAA,QAAO,CAAC,SAAS,GAAGC,UAAS"}